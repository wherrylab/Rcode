#This script is designed to perform a two-group DEG comparison on PORT results using
#the Limma-Voom DEG framework.

#R package dependencies:
#dplyr, tidyr, tibble, limma

#This script accepts a gene-level read count table generated by the PORT normalization
#and quantification pipeline. It them uses the Limma-Voom R packages to perform differential
#expression analyses (there are a few modifications required to get PORT to run smoothly
#with Limma-Voom; see Note1 and Note2 below). Lastly, this script returns the original
#PORT results table with extra columns for the Limma-Voom deg results (ie. log Fold-
#change, p-value, Benjamini-Hochberg-corrected Q-value)

#Note1: PORT is able to identify so-called "High Expressers", that it normalizes
#       differently from the other genes in a samples. The reads for non-highExp
#       genes are normalized, and then the high exp are handled separately and
#       added back to the count table. As a result, the read count totals for the
#       non-highExp are balanced across all samples (this is the desired outcome
#       for PORT). However, voom first performs a library size transformation to
#       stabilize the variance of the data (CPM calculation). This unbalances PORT-
#       normalized data since by default it normalized by library sizes that
#       include read counts from these high expressers. This effectively un-does
#       the normalization performed by PORT. To account for this, this script
#       accepts an optional argument which contains a comma-separated list of
#       gene IDs identified as highExp by PORT (if any exist). This script will
#       then exclude the read counts for these highExp genes when calculating
#       the library sizes for use in the CPM calculation. This will maintain
#       the normalization for all of the non-highExp genes.

#Note2: Running Limma-voom on PORT also runs into difficulties for genes with
#       with low expression (1-3 reads), when using few (<= 4) replictes. In
#       order to counteract this effect, we add random noise derived from a
#       normal(mean=0, sd=0.4) distribution to each read count.



#Usage: Rscript path/to/Perform_LimmaVoom_on_PORT_results.R \
#       path/to/PORT_results_table.txt \
#       path/to/output_file_root \
#       "<column_names_for_group_1_samples>" \
#       "<column_names_for_group_2_samples>" \
#       [list_of_gene_IDs_for_High_Expressers]

# path/to/PORT_results_table.txt
#       The gene-level read count table generated by PORT.
# path/to/output_file_root
#       The entire value of this argument will be apended to the output filename
#       as a prefix. This allows the user to specify the output directory for
#       this file, if it is different from the current directory. The output file
#       will have the following name: path/to/output_file_root.w_LimmaVoom_DEG_results.txt
# column_names_for_group_1_samples
#       Comma-separated list of column names in the PORT input file for those
#       samples in "group1".
# column_names_for_group_2_samples
#       Comma-separated list of column names in the PORT input file for those
#       samples in "group2".
# list_of_gene_IDs_for_High_Expressers
#       Optional argument specifying comma-separated list of gene IDs for those
#       genes identified as high-expressers.


#This helper function adds random noise to read counts. This random noise is
#drawn from a normal distribution with mean = 0 and sd = 0.4.
add_random_noise <- function(x) {
    
    r_value_to_add = rnorm(n=1, mean=0, sd=0.4)
    
    #To avoid negative exp values, add the absolute value of the random noise to 0-count data
    if(x == 0) {
        return(x + abs(r_value_to_add))
    } else {
        #Continue to generate random numbers until the sum of X and the random number
        #is >= 0 (this should rarely need to repeat).
        repeat{
            if(x + r_value_to_add >= 0) break
            r_value_to_add = rnorm(n=1, mean=0, sd=0.4)
        }
        return(x + r_value_to_add)
    }
}


#Suppress warning messages for duration of the script
oldw <- getOption("warn")
options(warn = -1)

#Load libraries required for the package
suppressPackageStartupMessages(library(dplyr, quietly = TRUE))
suppressPackageStartupMessages(library(tibble, quietly = TRUE))
suppressPackageStartupMessages(library(tidyr, quietly = TRUE))
suppressPackageStartupMessages(library(limma, quietly = TRUE))

#Read and process command-line arguments for this script:
args = commandArgs(TRUE)
port_input_file = args[1]
output_file_root = args[2]
group1_samples = args[3]
group2_samples = args[4]
#[Optional] Comma-delimited list of IDs for genes labeled as high exp by PORT
high_exp_ids = args[5]


#Load PORT-normalized read counts
read_count.data_table =
    read.delim(port_input_file, row.names = NULL) %>% 
    #Strip off "gene:" prefix for gene ID column (if present)
    mutate(id = gsub("gene:", "", id))
    
#Find the column indexes for samples in each group from the output dataframe
#(needed for gathering sample columns).
group1_sample_indexes = 
    which(colnames(read_count.data_table) %in% unlist(strsplit(group1_samples,
                                                               split = ",",
                                                               fixed = TRUE)),
          arr.ind = TRUE)
group2_sample_indexes = 
    which(colnames(read_count.data_table) %in% unlist(strsplit(group2_samples,
                                                               split = ",",
                                                               fixed = TRUE)),
          arr.ind = TRUE)


#Run data through voom

#Create design matrix
Grp1vGrp2 = factor(c(rep("Group1", times = length(group1_sample_indexes)),
                     rep("Group2", times = length(group2_sample_indexes))))
design_matrix = model.matrix(~Grp1vGrp2)

#Process PORT-normalized data with voom
data.matrix = 
    read_count.data_table %>% 
    select(id, group1_sample_indexes, group2_sample_indexes) %>% 
    column_to_rownames(var = "id") %>% 
    as.matrix()

#Get the list of genes that have zero expression in all samples (I don't want to add noise to
#these) I could just filter these out completely, but for the current analyses I want to keep
#these genes in my data matrix.
zero_genes = rownames(data.matrix[apply(data.matrix, 1, function(x) (length(unique(x))==1 & x[1] == 0)),])

#Remove NA values from PORT matrix, as they cause the downstream limma-voom analyses to fail
#(these arise from filtering out low expressers)
data.matrix = data.matrix[!apply(data.matrix, 1, anyNA),]


#Add random noise to each value in the matrix
data.matrix[] = vapply(data.matrix, add_random_noise, numeric(1))

#Revert genes with no expression across all samples back to 0 expression
data.matrix[zero_genes,] = 0

lib.sizes = colSums(data.matrix)
#Calculate library sizes by excluding high expresser genes (if any)
if(!is.na(high_exp_ids)) {
    #If there are multiple gene IDs, separate by comma
    ids_to_remove = unlist(strsplit(high_exp_ids, split = ",", fixed = TRUE))
    #Calculate library sizes excluding high expressers
    lib.sizes = colSums(data.matrix[!rownames(data.matrix) %in% c(ids_to_remove),])
}
port.voom_results = voom(data.matrix, design = design_matrix, lib.size = lib.sizes,
                         plot = FALSE, save.plot = FALSE)

#Use limma to perform DE analysis
port.deg_results = eBayes(lmFit(port.voom_results,design_matrix))


#Now merge the Limma-Voom logFC and p/Q-values with the original PORT table
merged.deg_results = 
    read_count.data_table %>% 
    left_join(topTable(port.deg_results, coef="Grp1vGrp2Group2", n=Inf, adjust.method="BH") %>% 
                  rownames_to_column("id"),
              by=c("id")) %>% 
    rename(LimmaVoom.pvalue = P.Value,
           BH.qvalue = adj.P.Val) %>% 
    select(id:geneSymbol, logFC, LimmaVoom.pvalue, BH.qvalue) %>% 
    arrange(LimmaVoom.pvalue)

#Restore warning message settings to old values
options(warn = oldw)

norm_counts<-as.data.frame(port.voom_results$E)

rownames(norm_counts)<-read_count.data_table$id

norm_counts$gene<-read_count.data_table$geneSymbol

norm_counts %>%
  write.table(file = paste(output_file_root, "w_LimmaVoom_NORM_log2_counts.txt", sep="."),
              quote = FALSE, sep = "\t", row.names = FALSE)




#Save the DEG results table
merged.deg_results %>%
    write.table(file = paste(output_file_root, "w_LimmaVoom_DEG_results.txt", sep="."),
                quote = FALSE, sep = "\t", row.names = FALSE)
